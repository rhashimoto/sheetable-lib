{
  "version": 3,
  "sources": ["../src/Spreadsheet.js"],
  "sourcesContent": ["// Set up lookup to convert between A1 spreadsheet cell notation\n// and row/column index. Most spreadsheets don't have 18,278 columns\n// so configure the mappings in batches.\n/** @type {string[]} */ const mapIndexToAlpha = [];\n/** @type {Map<string, number>} */ const mapAlphaToIndex = new Map();\n\nconst ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nconst ALPHA1_COUNT = 26;\nconst ALPHA2_COUNT = ALPHA1_COUNT + 26 * 26;\nconst ALPHA3_COUNT = ALPHA2_COUNT + 26 * 26 * 26;\n\n/**\n * @typedef Address\n * @property {number} columnIndex\n * @property {number} rowIndex\n * @property {number} [columnCount]\n * @property {number} [rowCount]\n */\n\nexport class Spreadsheet {\n  properties = {};\n  /** @type {Sheet[]} */ sheets = [];\n\n  /**\n   * @param {*} [title] \n   * @returns {Sheet}\n   */\n  addSheet(title) {\n    const sheet = new Sheet();\n    if (title) {\n      sheet.properties.title = title;\n    }\n    this.sheets.push(sheet);\n    return sheet;\n  }\n}\n\nexport class Sheet {\n  properties = {};\n\n  /**\n   * Specialization of setGridData() for setting values.\n   * @param {string|Address} range \n   * @param {string|number|boolean|((columnIndex: number, rowIndex: number) => string|number|boolean)} values \n   */\n  setGridValues(range, values) {\n    const f = typeof values === 'function' ? values : () => values;\n\n    this.setGridData(range, (columnIndex, rowIndex) => {\n      let userEnteredValue;\n      const value = f(columnIndex, rowIndex);\n      switch (typeof value) {\n        case 'string':\n          if (value.startsWith('=')) {\n            userEnteredValue = { formulaValue: value };\n          } else {\n            userEnteredValue = { stringValue: value };\n          }\n          break;\n        case 'number':\n          userEnteredValue = { numberValue: value };\n          break;\n        case 'boolean':\n          userEnteredValue = { boolValue: value };\n          break;\n        default:\n          break;\n      }\n      return userEnteredValue ? { userEnteredValue } : {};\n    });\n  }\n\n  /**\n   * @param {string|Address} range \n   * @param {(columnIndex: number, rowIndex: number) => object} f \n   */\n  setGridData(range, f) {\n    if (typeof range === 'string') {\n      range = Sheet.fromA1(range);\n    } else {\n      validateAddress(range);\n    }\n\n    range = Object.assign({\n      columnCount: 1,\n      rowCount: 1\n    }, range);\n\n    const gridData = {\n      startRow: range.rowIndex,\n      startColumn: range.columnIndex,\n      rowData: [],\n    };\n    for (let i = 0; i < range.rowCount; i++) {\n      const rowData = {\n        values: [],\n      };\n      for (let j = 0; j < range.columnCount; j++) {\n        const cellData = f(j + range.columnIndex, i + range.rowIndex);\n        rowData.values.push(cellData);\n      }\n      gridData.rowData.push(rowData.values.length ? rowData : {});\n    }\n\n    this.data = this.data ?? [];\n    this.data.push(gridData);\n\n    // Update grid size.\n    if (!this.properties.gridProperties) {\n      this.properties.gridProperties = {\n        rowCount: 0,\n        columnCount: 0\n      };\n    }\n\n    const gp = this.properties.gridProperties;\n    gp.rowCount = Math.max(gp.rowCount, range.rowIndex + range.rowCount);\n    gp.columnCount = Math.max(gp.columnCount, range.columnIndex + range.columnCount);\n  }\n\n  /**\n   * @param {string|Address} address \n   * @returns \n   */\n  getGridCell(address) {\n    if (typeof address === 'string') {\n      address = Sheet.fromA1(address);\n    } else {\n      validateAddress(address);\n    }\n\n    if (!(address.rowIndex < this.properties.gridProperties?.rowCount) ||\n        !(address.columnIndex < this.properties.gridProperties?.columnCount)) {\n      return null;\n    }\n    \n    for (const gridData of this.data?.toReversed() ?? []) {\n      if (address.columnIndex < gridData.startColumn) continue;\n      if (address.rowIndex < gridData.startRow) continue;\n      if (address.rowIndex >= gridData.startRow + gridData.rowData.length) continue;\n\n      const rowData = gridData.rowData[address.rowIndex - gridData.startRow];\n      if (address.columnIndex < gridData.startColumn + rowData.values.length) {\n        return rowData.values[address.columnIndex - gridData.startColumn];\n      }\n    }\n    return {};\n  }\n\n  /**\n   * @param {Address} address\n   * @returns {string}\n   */\n  static toA1(address) {\n    validateAddress(address);\n    const { columnIndex, rowIndex, columnCount, rowCount } = address;\n\n    // Ensure that the mappings are prepared.\n    const maxColumnIndex = columnIndex + (columnCount ?? 0);\n    if (maxColumnIndex > ALPHA1_COUNT) {\n      alpha2();\n      if (maxColumnIndex > ALPHA2_COUNT) {\n        alpha3();\n      }\n    }\n\n    const alphaX = mapIndexToAlpha[columnIndex];\n    const numberX = rowIndex + 1;\n    if (!rowCount) {\n      return `${alphaX}${numberX}`;\n    }\n\n    const alphaY = mapIndexToAlpha[columnIndex + columnCount - 1];\n    const numberY = rowIndex + rowCount; // 1-based so no need to subtract 1.\n    return `${alphaX}${numberX}:${alphaY}${numberY}`;\n  }\n\n  /**\n   * @param {string} address \n   * @returns {Address}\n   */\n  static fromA1 = (function() {\n    const re = /^([A-Za-z]{1,3})([1-9]\\d*)(?::([A-Za-z]{1,3})([1-9]\\d*))?$/;\n    return function(address) {\n      const m = address.match(re);\n      if (!m) throw new Error(`Invalid A1 address: ${address}`);\n\n      // let [, alphaX, numberX, alphaY, numberY] = m;\n      let alphaX = m[1];\n      let numberX = parseInt(m[2], 10);\n      let alphaY = m[3];\n      let numberY = m[4] && parseInt(m[4], 10);\n      if (alphaY) {\n        // Order coordinates low to high.\n        if (alphaY.lengh < alphaX.length ||\n            (alphaY.length === alphaX.length && alphaY < alphaX)) {\n          ([alphaX, alphaY] = [alphaY, alphaX]);\n        }\n        if (numberY < numberX) {\n          ([numberX, numberY] = [numberY, numberX]);\n        }\n      }\n\n      // Ensure that the mappings are prepared.\n      switch ((alphaY ?? alphaX).length) {\n        case 2: alpha2(); break;\n        case 3: alpha3(); break;\n      }\n\n      const columnIndex = mapAlphaToIndex.get(alphaX);\n      const rowIndex = numberX - 1;\n      const result = { rowIndex, columnIndex };\n\n      if (alphaY) {\n        // Counts are inclusive.\n        result.columnCount = mapAlphaToIndex.get(alphaY) - columnIndex + 1;\n        result.rowCount = numberY - rowIndex;\n      }\n      return result;\n    };\n  })();\n\n\n}\n\n// Add A to Z.\nfunction alpha1() {\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const index = mapIndexToAlpha.length;\n    const alpha = ALPHABET[i];\n    mapIndexToAlpha.push(alpha);\n    mapAlphaToIndex.set(alpha, index);\n  }\n}\nalpha1();\n\n// Extend mapping to ZZ.\nfunction alpha2() {\n  if (mapIndexToAlpha.length >= ALPHA2_COUNT) return;\n\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const a0 = ALPHABET[i];\n    for (let j = 0; j < ALPHABET.length; j++) {\n      const index = mapIndexToAlpha.length;\n      const alpha = a0 + ALPHABET[j];\n      mapIndexToAlpha.push(alpha);\n      mapAlphaToIndex.set(alpha, index);\n    }\n  }\n}\n\n// Extend mapping to ZZZ.\nfunction alpha3() {\n  if (mapIndexToAlpha.length >= ALPHA3_COUNT) return;\n\n  alpha2();\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const a0 = ALPHABET[i];\n    for (let j = 0; j < ALPHABET.length; j++) {\n      const a1 = a0 + ALPHABET[j];\n      for (let k = 0; k < ALPHABET.length; k++) {\n        const index = mapIndexToAlpha.length;\n        const alpha = a1 + ALPHABET[k];\n        mapIndexToAlpha.push(alpha);\n        mapAlphaToIndex.set(alpha, index);\n      }\n    }\n  }\n}\n\nfunction validateAddress(address) {\n  const { rowIndex, columnIndex, rowCount, columnCount } = address;\n\n  const isRowIndexValid = isNNI(rowIndex);\n  const isColumnIndexValid = isNNI(columnIndex);\n  const hasRowCount = rowCount !== undefined;\n  const hasColumnCount = columnCount !== undefined;\n  const isRowCountValid = !hasRowCount || isNNI(rowCount);\n  const isColumnCountValid = !hasColumnCount || isNNI(columnCount);\n  if (!isRowIndexValid || !isColumnIndexValid ||\n      !isRowCountValid || !isColumnCountValid ||\n      hasRowCount !== hasColumnCount) {\n    throw new Error(`Invalid address: ${JSON.stringify(address)}`);\n  }\n}\n\n// Test for non-negative integer.\nfunction isNNI(value) {\n  return value === (value | 0) && value >= 0;\n}"],
  "mappings": "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",
  "names": ["mapIndexToAlpha", "mapAlphaToIndex", "ALPHABET", "ALPHA1_COUNT", "ALPHA2_COUNT", "ALPHA3_COUNT", "Spreadsheet", "title", "sheet", "Sheet", "_Sheet", "range", "values", "f", "columnIndex", "rowIndex", "userEnteredValue", "value", "validateAddress", "gridData", "i", "rowData", "j", "cellData", "gp", "address", "columnCount", "rowCount", "maxColumnIndex", "alpha2", "alpha3", "alphaX", "numberX", "alphaY", "numberY", "re", "m", "result", "alpha1", "index", "alpha", "a0", "a1", "k", "isRowIndexValid", "isNNI", "isColumnIndexValid", "hasRowCount", "hasColumnCount", "isRowCountValid", "isColumnCountValid"]
}
